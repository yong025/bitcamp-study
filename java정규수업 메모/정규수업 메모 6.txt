레퍼런스와 인스턴스
레퍼런스 - 주소를 담고 있음
인스턴스 - 주소 안의 값을 담고 있음
int arr(int배열의 레퍼런스) = new int[3](int 배열의 인스턴스);

연산자 + - * / % (산술연산자)

값(리터럴,변수) + 값
값(피연산자)
+(연산자 oprator)

연산자 우선순위
* / %는 + -보다 먼저 연산
같은 우선순위는 순서대로 연산한다.
괄호를 묶으면 최우선 연산한다.

byte 2;
2=5+6;
byte x =5(리터럴);
byte y=6(리터럴);
z(1byte) = x(4byte)+y(4byte);

byte끼리의 연산 결과값은 int로 나오기 때문에 (결국 byte끼리 연산x) 기본 int로 인식.
z는 byte 변수로 안에 x와 y변수의 값을 담을 수 없음.

데이터 타입과 연산자

int + - * / % ..
boolean && || ..
문자열 +
floak + - * / % ..
각 데이터타입에 대해 사용할 수 있는 연산자가 제한되어 있다. 

연산 결과의 타입( ex05 Exam 0141/Exam 0142)
int i =5;
int j= 2;
float r = i / j; = 2.0출력
**** int 와 int 연산 결과는 정수로 값을 출력한다. ****
float r = (float)i / (float)j; = 2.5출력
형변환으로 임시 float 메모리 생성.
(서로 데이터타입이 달라도 연산이 안됨.)
모든 연산은 미리 형변환을 거친 뒤에 연산한다.

암시적 형변환 규칙
implicit type - conversion(casting)
byte + short / short + int / byte + int 는 암시적 형변환을 통해 int로 자동 변환된다.
byte + short = int
byte + int = int
short + int = int
char + int = int

int + long = long으로 암시적 형변환
long(8byte) + float(4byte) = float (무조건 정수가 부동소수점으로 변환/8byte 데이터 소실 가능성)
long + double = double

논리 연산자: &&/& , ||/|
&& / ||
boolean a = false
boolean b = false
boolean r = a(false) && (b = true) ; = false
앞의 값으로 결과를 예측 할 수 있다면 뒤의 식은 수행하지 않는다.
& / |
boolean a = false
boolean b = false
boolean r = a(false) & (b = true) ;
r = a(false) & b(true) = false ;
앞의 값으로 결과를 예측할 수 있더라도 무조건 뒤의 식을 실행한다.

&를 이용하여 %연산 처리하기

(값 % 2) == 0 >> 짝수
(값 & 0x1(맨끝 1bit만 추출)) == 0 >> 짝수
(ex. 10101111 맨끝의 비트가 1인지(홀수) 0인지(짝수) 확인)
ex.  
값0001 0010 & (둘다 1일때 1)
   0000 0011
-----------------
   0000 0010
으로 마지막 1bit만 확인하면 짝수/홀수 구별 가능

10 2한개 나머지 2보다작음
110 4한개 나머지 4보다 작음
1110 8 한개 나머지 8보다 작음
101001111110 << 앞은 무조건 2,4,8의 배수
xxxxxxxxxxx 뒤의 3bit만 추출 (8보다 작은 수)
X %2 >> X&0x1(2뒤의bit)2로 나눈 나머지
X %4 >> X&0x3(4뒤의 bit)4로 나눈 나머지
X %8 >> X&0x7(8뒤의 bit)8로 나눈 나머지
X %16>> X&15 16으로 나눈 나머지
*** %연산보다 비트연산이 계산속도가 빠름.***

& 연산의 또다른 응용(색상 변형)
&(AND)연산자는 "-"   |(OR)연산자는 "+" 이다.

1. PIXEL RGB:	1100011(R) 11000001(G) 11101011(B)
파란색을 축소   &	1111111	  11111111     01010101
		0100011	  11000001     01000001

2. PIXEL RGB:	01100011(R) 11000001(G) 11101011(B)
빨강색을 강화    |	10101010	    00000000     00000000
		11101011     11000001     11101011

비트 이동 연산

x << 1 = x * 2	  = x * 2
x << 2 = x * 2(의 2승)= x * 4
x << 3 = x * 2(의 3승)= x * 8
( " * "연산보다 계산 속도가 빠르다. ) 

***음수 이동***
음수를 왼쪽으로 이동할 때는 부호비트에 상관없이 무조건 이동
int a = -0x7f_ff_ff_fa; // -21_4748_3642
System.out.println(a);      //     [10000000000000000000000000000110]
System.out.println(a << 1); //    1[00000000000000000000000000001100] = 12
System.out.println(a << 2); //   10[00000000000000000000000000011000] = 24
System.out.println(a << 3); //  100[00000000000000000000000000110000] = 48
System.out.println(a << 4); // 1000[00000000000000000000000001100000] = 96

비트 이동의 최대크기

int 값 x << y = x << y(의 1승) = y &0x1F(011111) = y %32
x << 1 = x << 33( 33 % 32= 1 )
x << 65( 65 % 32= 1 )

오른쪽의 비트이동
x >> 1 = x / 2 = x / 2
x >> 2 = x / 2(의2승) = x / 4
x >> 3 = x / 2(의3승) = x / 8
(양수에서는 소수점이 있을 시, 버린다.(43.5 >> 43))
(음수에서는 소수점이 있을 시, 반내림(-43.5 >>-44))

비트를 활용한 true/false 설정
문제: 1-개의 항목에 대해 true/false 값 저장하라

1. boolean b1,b2 .. b10;
2. boolean[ ] arr =new boolean[10];
3.int state; (정수 메모리의 각 비트에 항목의 값을 저장하면4byte 만으로 32개 항목에 대해 값을 저장할 수 있다.) true(1)/false(0)

용어정리: Statement 와 Expression

int a; << statement
if (-) { } << statement
a + 2 << statement
(a+2는 실행결과를 생성(리턴)하는 statement(문장)는 Expression(표현식)이라고 한다.)
statement = 명령문
expression = 결과를 리턴하는 명령문

후위연산자 전위연산자

a++ 후위연산자 - a변수의 값을 현재 위치에 놓는다. / a변수의 값을 증가
++a 전위연산자 - a변수의 값을 증가 / 현재 위치에 변수값을 놓는다.






