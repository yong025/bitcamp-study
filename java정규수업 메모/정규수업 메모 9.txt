메서드 = 함수
-명령어(문장)를 **관리하기 쉽게** 기능 단위로 묶는 문법
(**메서드명은 어떤 기능을 수행하는 명령어들 이라는 의미에서 동사구 형태로 이름을 짓는다.
메서드명(변수 선언(메서드를 실행할 때 외부에서 받는 값을 담을 변수(파라미터), 변수 선언, ...) {
   명령문(ex.변수선언,연산자,조건문,반복문..)
   return 값;(리턴타입 (메서드가 리턴하는 값의 데이터타입))
}

**메서드 사용**(미리 만들어 놓은(메서드 정의definition) 메서드를 실행(호출 call))
변수 = 메서드명( 값 값, .... ) ;

변수 = 메서드가 리턴하는 값을 받는 변수/리턴값의 데이터 타입과 같아야한다.
메서드명 = 실행할 메서드명
값 = 메서드를 설정할 때 파라미터에 넘겨주는 값/"아규먼트(argument)"라고 부른다.
(값은 메서드의 파라미터 갯수와 일치해야한다./각 파라미터의 데이터타입과 맞아야한다.)
메서드의 4가지 유형

1. void(값을 리턴하지않음) m(외부에서 값을 받지 않음) {
-
}
ex. m( ) ;

2. void m(int p1(int타입의 값을 받아야한다.), boolean p2(boolean타입의 값을 받아야한다.) {
-
}
ex, void m(100, true)

3. int(메서드가 어떤 타입의 값을 리턴할 지 선언) m() {
-
   return 100; (메서드를 실행 후 int타입의 값을 리턴한다.
}
ex. int result;
result = m( ) ; (100을 리턴) (m( );은 리턴값을 받을지 말지 자유롭게 결정)

4. int(리턴타입 선언) m(int p1(파라미터 선언),int p2) {
if ( p1 > p2 )
   return p1;
 else
   return p2;
}
ex. int result;
result = m(200,300);(<< argument(파라미터의 넘겨주는 값)
p2값 300이 result값으로 나옴

*메서드 사용 예*
main( ) {
while ( ) {
-(별 출력 전 공백 출력코드)  print spaces
-

-(별을 출력하는 코드)
-

-
-
   }
}

메서드 호출 flow
ex.
class Exam0210 {
     hello( ) { 2.
---3.
---
}
     1.main( ) {
---
---
4.hello( );(1.main에서 출발 >>hello를 만나면 위의 hello로 이동)
5.---
---
  }
}

실행 흐름 (thread)
-JVM을 통해 클래스를 실행하면 1개의 실행흐름이 생성되어 main() 메서드에서 출발한다.
-명령어를 실행하는 흐름이 끊기지 않는 실과 같다하여 '스레드(thread)'라 부른다.
-main() 메서드에서 출발하는 실행흐름을 자바에서는 '메인 스레드'라 부른다.
-자바에서는 메인스레드와 별개로 새 실행흐름(스레드)를 만들 수 있다.
-서로 간의 간섭없이 여러개의 실행 흐름이 동시에 진행하는 것을 "멀티 스레딩"이라 부른다.(서버 개발에서 사용됨)

로컬변수(local variables)

class Exam0220{
  main() {
   int a; << main()에서만 사용할 수 있다. (그래서 지역(local)변수라 부른다.)
   hello(100);
}
 hello (int p) { <<특히 p변수는 메서드 호출 시 넘어오는 값을 담는 변수로써 '파라미터'라 부른다.
   int x; << hello()에서만 사용할 수 있다. (그래서 지역(local)변수라 부른다.)
    -
  }
}

JVM 메모리 영역

method area: .class 명령코드/ static 변수/
heap: new 명령으로 만드는 변수(인스턴스)
JVM stack: 메서드를 호출할 때 마다 로컬변수를 생성 >메서드 호출이 끝나면 그 메서드의 로컬변수가 제거된다.



