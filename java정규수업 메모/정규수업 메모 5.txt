데이터 저장

1. 정수 >>2의 보수 >> 2진수 >> 메모리
2. 문자 >> (utf-16) 유니코드 2바이트 >>2진수 >> 메모리
3. 논리 >>true= 1 false= 0 >> 2진수 >> 메모리
4. 부동소수점(실수) >> IEEE-754 >> 2진수 >> 메모리

부동소수점(소수점이 이동) (IEEE 754명세)
부동 소수점을 2진수로 변환
12.375 = 123.75*10(의-1승) = 1237.5*10(의 -2승) = 12375*10(의 -3승) 
12를 2진수로 =1100
.375를 2진수로 변환하는 법
- .375
- 소수점을 2로 곱하여 나온 결과에서 정수 부분만을 차례대로 표기한다.
- 소수 부분이 0이거나 반복되면 계산을 멈춘다.
- 예: 0.375(10진수)
0.375 * 2 = 0.75  --> 0
0.75 * 2  = 1.5   --> 1
0.5 * 2   = 1.0   --> 1
=> 0.011(2진수)
합치면 = 1100.011 >> 정규화(소수점을 좌측 맨끝으로 3칸 이동) >>1.100011 * (2진수) 2(3승)
가수(1을 제외한 .밑의 수)(23비트) 지수(3승)(8비트)를 분리
지수는 Excess k 방법에 따라 2진수로 변환 >> 3 + 127 = 130 >>2진수는 10000010
- [1:부호비트][8:지수부][23:가수부] = 32비트
- 예) 0_10000010_10001100000000000000000
= 01000001_01000110_00000000_00000000
= 41_46_00_00(16진수)(4bit씩 쪼개기)
- -12.375

인코딩/디코딩

-사진(RGB) 3바이트 * 해상도(화소) (1920*1080) = 620만 바이트
-바이트(나누기 1024) >> 킬로바이트 (나누기 1024)>> 메가바이트값
-A형태 데이터 >> B형태 데이터로 변환(인코딩) >> A형태로 재변환(디코딩)

메모리 크기에 따른 부동소수점 저장 범위

4byte 메모리 - 최대 유효자릿수 7자리 까지 거의 정상적으로 저장가능(99.9%)
8byte 메모리 - 최대 유효자릿수 16자리 까지 가능 
*유효자릿수: 소수점을 뺀 숫자의 개수 (ex. 12.375 다섯자리)
*정수의 경우 " -x ~ +y " 식의 범위가 명확
*부동소수점은 IEEE 754방식에 따라 2진수로 바뀌기 때문에 " -0 ~ +0 " 범위가 명확게 정의 불가

부동소수점과 유효자릿수

유효자릿수라도 저장할 때 완전히 2진수로 변환불가 경우 발생.
소수점 이하의 수를 2진수로 바꿀때 딱 떨어지지 않는 경우가 있다.
>> 일부 부동소수점을 2진수로 완벽히 변환불가 !(적절히 반올림해서 사용해야 한다.)

프로그래밍 기본문법

1. Data를 표현하는 방법 >> 리터럴(literal)
2. Data를 저장하는 방법 >> 변수 선언 (variables)
3. Data를 연산하는 방법 >> 연산자(operator)
4. 명령어의 흐름을 제어하는 방법 >> 조건문, 반복문
5. 명령어를 기능단위로 묶는 방법 >> 메서드

데이터를 저장하는 방법
- 데이터를 저장할 메모리를 준비시킨다.
- 준비한 메모리에 데이터를 입력한다.
변수 선언 명령 문법
[메모리 종류] [메모리의 라벨];
 데이터 타입         변수 
ex. 
int age;
float height;
boolean working;
char gender;

정수값을 저장할 메모리를 준비시키는 명령어

정수 메모리의 데이터타입
byte(1byte) / short(2byte) / int(4byte) / long(8byte)
byte kor; -128 ~ 127
short ton; -32768 ~ 32767
int popul; 약 -21억 ~ 21억
long balance; 약 -922경 ~ 922경

부동소수점 데이터 타입 (단정도 / 배정도)
float(4byte) / double(8byte)
float height; (유효자리수 7자리)
double money; (유효자리수 16자리)

논리값 데이터 타입
 *배열일 경우 각 boolean 변수는 1byte로 다뤄진다.
boolean(4byte) (true = 1 / false = 0)
boolean working;

문자 데이터 타입
char(2byte) unicode2(utf -16) (0 ~ 65535)

확보된 메모리에 값 저장하기
"=" (assignment operator) 할당 연산자 = 대입 연산자
[변수명] = 값;
ex. a(variable) = 20(literal);
[변수명] = [변수명];
ex. b = a;

left-value 와 rignt-value
a = 20;
b = a;
(a변수에 들어있는 값을 b변수에 저장한다.)
l-valeu (변수만) = r-value (리터럴 및 변수)

char 변수와 int 변수

char c;
int i;
c= 65;
i= 65;
system.out.println(c); >>A문자 출력 (println은 65숫자가 유니코드임을 인식. 해당 코드문자 출력)
system.out.println(i); >> 숫자 출력 (println은 65가 숫자임을 인식. 숫자를 10진수로 출력)

배열 - 같은 종류의 메모리를 여러개 준비하는 방법

int a, b, c, d, e ; (메모리가 연속된다는 보장은 없다. 각 변수마다 메모리가 따로따로 준비된다.)
int[] arr = new int[5]; (메모리가 연속해서 준비된다.)

배열 선언과 배열의 값 저장

데이터타입[ ] 변수명 = new 데이터타입[개수]; (이 방법을 선호함)
데이터타입 변수명[ ] = new 데이터타입[개수];

변수명[ 인덱스 ] = 값;
인덱스 = 0 ~ (개수 -1만큼)

배열 변수와 배열 메모리

int[ ] arr= new int [5];
 arr은 일반 값이 아닌 배열 메모리의 시작주소를 저장한다.
이런 변수를 "레퍼런스(reference)라고 한다.

***값을 저장하는 primitive data type변수와
***주소를 저장하는 reference 변수가 있다.
ex. 
int a
a = 100;
asms 단순 값
int[ ] r = new int[5];
r[0] = 3 
r의 값은 메모리의 주소가 된다.
int[ ] b;
b = r;
(배열 b를 선언 후 r의 주소를 b에도 대입할 수 있다.)
System.out.println(b[0])

새로운 배열변수 선언
int[] a = new int[3];
a[0] = 100;
a[1] = 200;
a[2] = 300;
//밑에 a를 다시 선언하면 상단은 주소만 갖고 있고 레퍼런스가 한개도 없다.>>사용불가>> garbage
a = new int[5];
System.out.println(a[0]);
(값은 두번째 선언한 변수의 첫번째 값인 0이나옴)
(첫번째 배열은 주소 소실로 사용할 수 없음.)
JAVM 실행되는 동안 가비지를 찾아 제거하고 재사용한다.
JVM 종료시 JVM이 사용한 메모리를 OS에 반납한다. 가비지도 반납

Garbage Collector
가비지를 제거하여 사용할 메모리를 확보한다.
-메모리가 부족할 때
(메모리가 부족하지 않으면 JVM이 종료할때까지 가비지컬렉터 실행X)
-CPU가 여유가 있을 때

배열 초기화

int[ ] arr = new int[3];
arr[0]=100;
arr[1]=200;
arr[2]=300;

int[ ] arr2 = new int[ ]{100,200,300,}; (위에 식을 한번에 줄여 출력하는 방법)